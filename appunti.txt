cout << "joinAndLinkPaths()" << endl;
    
    int cont = 0; //serve come contatore per il plot con i numeri per seguire il percorso (+1 per ogni inizio e ogni fine di singolo path)
    
    //collego startingPoint con firstVertex 
    m_finalPath.push_back(CGAL::Segment_2<K>(m_startingPoint, m_firstVertex)); 

    //plot del punto di partenza 
    m_Helper.plotPoint(m_startingPoint, 'b', cont); 
    cont++; 
    
    m_Helper.plotPoint(m_firstVertex, 'b',  cont);
    

    size_t num_perimeterEdges = m_simplyfiedPolygon->edges().size();
    //cerco il lato del perimetro il cui source è firstVertex
    size_t indexFirstVertex = 0; 
    for (size_t i = 0; i < num_perimeterEdges ; i++) {
        if (m_simplyfiedPolygon->edge(i).source() == m_firstVertex) {
            indexFirstVertex = i; 
        }
    }

    //Inserisco nel path il perimetro (partendo e tornando in firstVertex)
    size_t j = indexFirstVertex;  
    for (size_t i = 0; i < num_perimeterEdges; i++) {
        m_finalPath.push_back(m_simplyfiedPolygon->edge(j)); 
        //m_Helper.plotPartialPath(m_finalPath, -1);
        j = ((j+1)%num_perimeterEdges);
    }
    cont++; 

    //RIPRENDI DA QUA 

    // poi collego il punto iniziale al punto da cui si parte del primo sottopoligono
    m_finalPath.push_back(CGAL::Segment_2<K>(m_firstVertex, m_pathS[0][0].source()));
    m_Helper.plotPartialPath(m_finalPath, cont);
    cont++; 

    // poi tutti i path dei sottopoligoni
    for (size_t i = 0; i < m_pathS.size(); i++)
    {
        for (size_t j = 0; j < m_pathS[i].size(); j++)
        {
            m_finalPath.push_back(m_pathS[i][j]);
        }
        m_Helper.plotPartialPath(m_finalPath, -1); //disegna le strisciate, 


        // collego l'ultimo punto del path precedente col primo del successivo
        if (i != m_pathS.size() - 1)
        {

            CGAL::Segment_2<K> segment_new;
                
            float distance1, distance2; 
            int index; 

            vector<int> route = findMinRouteBetween(m_polygonsSorted[i], m_polygonsSorted[i+1]);

           
            for (size_t j  = 0; j < route.size()-1; j++) {

                if ((m_adj[route[j]][route[j+1]][0] == -1 && m_adj[route[j]][route[j+1]][1] == -1)) { // non sono adiacenti
                    cout << "CoveragePathCreator::cover error" << endl;
                    return;
                }
                
                // scelgo il punto dell'adiacenza a distanza minima
                distance1 = CGAL::squared_distance(m_pathS[i][m_pathS[i].size() - 1].target(),
                                                        m_decomposedVertices[m_adj[route[j]][route[j+1]][0] ]  ) +
                                    CGAL::squared_distance(m_decomposedVertices[m_adj[route[j]][route[j+1]][0]], m_pathS[i+1][0].source());
                

                distance2 = CGAL::squared_distance(m_pathS[i][m_pathS[i].size() - 1].target(),
                                                        m_decomposedVertices[m_adj[route[j]][route[j+1]][1]] ) +
                                CGAL::squared_distance(m_decomposedVertices[m_adj[route[j]][route[j+1]][1]], m_pathS[i+1][0].source());


                if (distance1 <= distance2)
                { // passo per il punto 1
                    index = 0;
                }
                else
                { // passo per il punto 2
                    index = 1;
                }

                //se non sono già collegati
                if (! ( m_finalPath.at(m_finalPath.size()-1).target() == m_decomposedVertices[m_adj[route[j]][route[j+1]][index]])) {
                    
                    segment_new = CGAL::Segment_2<K>( m_finalPath.at(m_finalPath.size()-1).target() , m_decomposedVertices[m_adj[route[j]][route[j+1]][index]]);
                  
                    m_finalPath.push_back(segment_new); // inserisco il primo collegamento : dal target del path i-esimo al vertice di collegamento 
                    m_Helper.plotPartialPath(m_finalPath, cont);
                    cont++; 
                }
            }           
            
            //unisco con il source del path i+1 esimo 
            segment_new = CGAL::Segment_2<K>( m_finalPath[m_finalPath.size()-1].target(), m_pathS[i+1][0].source());
            m_finalPath.push_back(segment_new); // inserisco il secondo pezzo
            m_Helper.plotPartialPath(m_finalPath, cont);
            cont++; 

        }
    }
